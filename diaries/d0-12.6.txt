创建时间：	2017/12/7 星期四 上午 8:44

一.约束:通过各种约束来保证表中数据的完整性
1.分类
a)not null: 非空约束
b) unique: 唯一约束,自动给该列添加唯一索引,可以有null值
c)primary key: 主键约束, 自动给主键列添加聚集索引,一个表中通常只有一个主键,不过一个主键可以包括多行列.不能存在null值,就是一个不能包含null值的唯一约束
d)foreign keu: 外键约束, 该列的值来自其他表(父表)的主键或者唯一键,且该列的类型要与父表中主键或唯一键的类型一致.
e)check: 检查约束, 根据自己设定的规则要求列满足某些要求
2.添加方式
a)创建表时直接在列后面添加
①可以直接指定的有 primary key, not null, default, unique,check.外键的直接指定格式: constraint 外键名 references 父表 (列名)
②写在对应列后面的列称为列级别约束, 定义时可以在列后面直接指定,一个列级别约束只能作用在一个列上
③写在所有列后面的约束称为表级别约束,一个表级别约束既可以作用于一个列上,也可以作用在列的组合上
    constraint 约束名 约束类型 (列)
④ not null 约束只能是列级别的约束,not null 本质上是一个指定列not null的检查约束
b)创建完表后通过alter命令追加约束
alter table 表名 add constraint 约束名 约束类型 (被约束的列)
追加not null 约束时需要使用modify子句而不是add
c)外键的级联操作
①set null: 当删除主表中被引用列的数据时, 把子表中相应的引用的列的值设为null,前提是子表中该列必须允许为空
                在添加外键时的最后面加上 on delete set null
②cascade:级联删除,删除主表中被引用列的数据时, 同时删除子表中引用列的值与之相等的数据行.
                在最后面加上 on delete cascade
3.删除约束
alter table 表名 drop primary key | 约束类型 (受约束的列) | constraint 约束名
删除主键约束只需 drop primary key,
删除unique需要在drop后添加 约束类型 (受约束的列)
删除外键或not null 和 check 约束需要在drop后面添加constraint和约束名
4.约束的禁用与启用
禁用: alter table 表名 disable constraint 约束名
启用: alter table 表名 enable constraint 约束名
二.视图---是一个虚拟表,只存放select语句,不存放数据
1.创建视图
create {or replace] [force | noforce] view 视图名 [(列名)]
as 一条子查询语句
[with check option [constraint 约束名]]
[with read only]
or replace:如果创建的视图已存在,则修改视图
force: 不管视图所基于的表是否存在都会创建视图
no force:只有视图所基于的表存在才会创建视图
with read only:该视图只读
2.必须要具有创建视图的权限才能创建视图
授予创建视图权限: grant create view to 用户
3.删除视图
drop view 视图名
ps: 可以通过视图对其基表进行DML操作,需要视图满足一定条件
4.视图和表的区别
a)视图是虚拟的表,只存放SQL语句, 执行时是从表中取数据
   表用来存放数据
b)通常视图仅用于查询,不一定可以进行DML操作
   表可以执行CRUD的任意操作
三.序列---按照一定规则自动增加或减少数字的数据库对象
1.创建序列
create sequence 序列名
[increment by n] : 步进值
[start with n]: 起始值, 起始值必须大于序列指定的最小值
[maxvalue n | nomaxvalue]: 序列最大值或无最大值
[minvalue n | nominvalue]: 序列最小值或无最小值
[cycle | nocycle]: 序列达到极限后是否继续产生序列值,默认nocycle   
[cache n | nocache]:预先缓存的序列值,nocache不缓存, cache20是默认选项
2.常用属性
nextval: 获取序列的下一个值
currval: 获取序列的当前值,在使用currval之前必须至少使用一次nextval
3.一条SQL语句只能从序列中获取一次数值,且不管SQL语句操作是否成功,序列都会向下,所以在同一条SQL语句中不管有几个nextval或currval,获取的值都是相同的
4.修改序列
alter sequence 序列名 ....
除了不能修改序列起始值外,其他的属性都能修改
5.rowid: 是一个系统自动产生的伪列,是唯一能标示每一条数据库行记录的物理地址
四.索引---类似于新华字典的音序,用于加快数据的检索速度
1.分类
按照是否排序
a)聚集索引: 相当于新华字典的音序,在索引页中靠前的记录,在表中也靠前.一张表中仅有一个聚集索引,通常为主键列,只要表中创建了主键便会自动添加聚集索引
b)非聚集索引:非聚集索引是逻辑上连续但物理存储上并不连续的,所以位置不一定一致,通常创建的都是非聚集索引
按索引列数
    单列索引
    多列索引
    函数索引:以函数的执行结果作为索引,当经常要访问一些函数或表达式时,将其存储值索引,免去再次计算,不能使用聚合函数
c)按存放数据格式
    B-Tree 索引, 一个二叉树,默认创建的都是B-Tree索引,保存排序过的索引列和对应的rowid值,适应于精确查询,模糊查询,比较查询
    位图索引
    反向键索引
2.创建方式
自动创建:
①聚集索引,只要创建主键便自动添加,
②唯一索引: 只要设置列为unique约束后便自动添加
手动创建:
create index 索引名 on 表(列)
创建索引时列使用了什么样的格式,只有以匹配格式的列作为条件索引才起作用
3.适合创建索引的情况
①表数据量很大
②查询的结果集占2%-4%左右
③经常用于做where条件的列或多表连接条件的列
④查询的列数据范围分布很广
⑤查询的列中包含大量的null值.null值不包含在索引中
4.不适合创建索引的情况
①数据量较小
②不常用来作为查询条件的列
③频繁更新的列
④值较少的列, 即重复数据不多的列
5.缺点:占用空间, 降低DML操作速度
6.会导致索引失效的情况
①在where子句中使用 != 或 <>时
②在where子句中使用or来连接条件时
③如果列类型是字符串.但在条件中没有将数据使用引号括起来
④like模糊查询时以 % 开头
⑤在where子句中对列进行函数操作,表达式操作,算数运算时, 所以尽量少对原始数据进行修改
五.同义词
为数据库对象创建的别名,简化过长的对象名称,对数据库对象的访问进行简化,并方便其他用户的访问.
只有数据库管理员才有公有同义词的创建和删除权限
1.创建同义词:  create [public] synonym 同义词名称 for [用户名.]对象名
2.同义词在数据库链中的作用
a)数据库链是一个命名的对象,说明一个数据库到另一个数据的路径,通过数据库链可以实现不同数据库之间的通信
b)数据库链的创建
create database link 数据库链名 connect to 用户名 identified by 密码 using 'oracle连接串'
oracle连接串可以是Net Manager中配置好的服务名,也可以是tnsnames.ora文件中相同格式的description中的内容
c)访问对象通过 object名@数据链名来访问,同义词在数据库链中的作用就是提供位置透明性