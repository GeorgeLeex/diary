创建时间：	2017/11/15 星期三 下午 6:43

一.
1.父类引用指向子类对象,通过该引用只能访问父类中声明的属性和行为,或者在子类中被重写的行为,子类中特有的属性和行为无法访问 
2.通过 引用. 访问属性或行为的方式
    ①类型: 决定可以访问的成员
    ②new 后面的类型: 决定成员的出处
    ③Father father = new Son();调用方法取决于运行期间是哪个对象调用的它,规则是优先调用自己的方法如果自己没有这个方法,即没有重写这个方法,则调用父类的这个方法
3.继承关系创建子类对象的过程
    ① 首先ClassLoader类调用loadClass方法加载类(自动加载继承关系中涉及的所有类),同时自上而下的执行static修饰的内容,同一类中的静态成员变量和静态代码块也是按照代码位置顺序执行的
    ②此时类加载完毕,可以创建对象了，首先将对象中的实例变量全都被设为默认值，然后调用父类的构造方法,默认自动调用，也可以用super来指定调用。父类构造器和子类构造器一样以相同的顺序经历相同的过程，直到Object。
    ③然后再自上而下的按照顺序执行普通代码块和普通成员变量的初始化,初始化完之后,再执行构造方法中其余的语句
二.static
一般来说，类的代码在第一次使用被加载，即创建某个类的第一个对象时，但是当访问类的静态域（final修饰的除外）或静态方法时也会发生加载，同时构造器其实也是static方法，只是并没有显示的指出来，所以总的来说类的代码加载发生在第一次访问类的静态成员时。
4.static修饰的属性和代码块在类加载的时候执行,且仅执行一次
5.static不能修饰局部变量,一是java语法规定,被静态修饰的成员变量和方法随着类的加载而加载,局部变量随着方法的调用而创建
6.static修饰的内容属于类,被该类的所有对象共享.
7.静态方法里只能直接访问静态成员,不能直接访问类中的非静态成员,
8.静态方法中不能使用this super关键字,this super表示的都是对象的引用,静态的内容加载类的时候就执行了,那时还没有对象,所以无法使用
9.静态方法不能被非静态方法覆盖,static不能修饰构造器
10.static修饰的方法不能被重写,因为它属于类而不是属于对象
11.java中静态方法静态绑定,静态方法的选择是编译期就选择好的,是编译期自动根据声明类型帮我们选择的,不依赖于任何对象，所以静态方法不具有多态性
三.final--表示终态的
        1.修饰类：该类不能被继承
        2.修饰方法：
        ①该方法不能被重写，如今不必为了效率而去将方法修饰为final
        ②所有的private方法都被隐式的指为final。
        3.修饰变量：
        ①变量的值不能改变(就是不能再重新赋值，称为常量)，如果为引用类型，使其引用不可变。可以修饰类变量，实例变量，局部变量
        ②Java允许空白常量，即声明了但又未给定初始值的常量，但使用前必须初始化，所以要么在声明处赋值要么在每个构造方法中为其赋值
        ③当将参数列表中的参数用final修饰时，表明在方法内部无法更改参数的值
            
    String、System、Math 都是 final 修饰的类
    final 不能修饰 构造方法
四.单例模式
    保证该类在内存中只有一个对象,目的就是为了解决对象过多的问题
    单例模式编写步骤
    a)构造方法私有，可以保证 构造方法在类的外面无法访问，避免 被 new
    b)创建一个私有的、静态的本类对象，用于判断该类是否有对象
    c)创建一个公有的、静态的返回本类对象的方法，用于向外输出本类的对象

单例模式的两种写法
 懒汉式---需要时再去创建对象
 public class Singleton{
    private static Singleton single;
    private Singleton(){}
    public static Singleton getInstance() {
        if (single == null) {
            single = new Singleton();
        }
        return single;
    }
}
饿汉式---类一加载,就先创建本类对象
public class Singleton {
    private static final Singleton single = new Singleton();
    private Singleton(){}
    public static Singleton getInstance() {
        return single;
    }
}
五,抽象类与抽象方法
    抽象类:包含抽象方法的类
    抽象类不能被实例化,必须通过其子类构建
    抽象类中可以包含抽象方法，也可以不包含
    包含抽象方法的类 必须是抽象类，抽象类不一定有抽象方法
    抽象方法:
    只有方法声明,没有方法实现的方法
    使用抽象方法的原因:父类中的方法必须在不同的子类中覆盖,就把方法定义为抽象方法
    
    