创建时间：	2017/12/12 星期二 下午 7:13

一.泛型
1.自定义泛型类
在类名或接口名后面添加一对尖括号 <泛型类型> 一般用T表示,Type的缩写,且T只能是引用类型,不能用基本类型填充
a)当实例化泛型类的对象时指明泛型类的类型,那么其中所有使用泛型的位置都变为实例化所指定的类型
b)当定义了泛型类,但实例化是没有指明泛型,那么默认类型时Object
c)在继承泛型类或者泛型接口时可以指定父类的泛型类型使其子类受到指定泛型的影响
d)普通静态方法中不能使用类的泛型,但泛型方法可以,泛型是在类实例化之后才能确定实际类型,但static修饰的内容是早于对象的
e)不能再catch块中使用泛型
2.泛型方法
在方法的修饰符之后, 返回值之前添加一个 <泛型>,那么该方法就成了一个泛型方法, 通常把参数的类型定义为 该方法的泛型类型 ,把返回值类型也定义为 该泛型,就可以使其返回值类型动态的与参数类型相同
3.泛型和继承的关系
如果B是A的一个子类型(子类或者子接口),G是一个有泛型声明的类或接口,G<B> 不是 G<A> 的子类. 具有继承关系的类作为泛型类的类型并不会使其泛型类具有继承关系
4.通配符 ?
a)使用? 泛型的对象是 各种泛型的父类
b)读取List<?> 的对象中的元素十分安全,因为不管其真是类型是什么,它包含的都是Object
c)不能向List<?>的对象添加元素, 因为不知道其确切的元素类型,不过可以添加null,因为null是所有类型的成员
d)限制通配符
① <? extends 引用类型>: 只允许泛型为指定类型以及其子类的引用调用,只能放其本身及其子类
② <? super 引用类型> : 只允许泛型为指定类型及其父类的引用调用,只能放其本身及其父类
③ <? extends 接口名>: 只允许泛型为实现指定接口的实现类的引用调用,只能放该接口的实现类